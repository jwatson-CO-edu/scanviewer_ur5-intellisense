\documentclass{hw_grad}

% === RECIPES ==============================================================================================================================

% ~~ FIGURE ~~
%\begin{figure}[h]
%	\centering
%	\includegraphics[scale=0.45]{imaginativeAndGenerative}
%	\caption{Relationship between Generative and Imaginative}
%	\label{imaginativeAndGenerative}
%\end{figure}

% ~~ Answer Boxes ~~
% Inside Eq: \boxed{}
% Text:      \fbox{}
% Region:    \begin{framed} ... \end{framed}
%            - OR -
%            \fbox{% Will complain is there is not a comment at the end of the open bracket line
%            	...
%			 }

% ___ END RECIPES __________________________________________________________________________________________________________________________


\title{Presentation Notes}
\duedate{Due: 2018-12-13}
\class{CSCI-5229: Computer Graphics, Fall 2018}
\institute{University of Colorado Boulder}
\author{James Watson, 105754866}

\begin{document}
	\maketitle
	
	\begin{enumerate}
		\item Demo
		\begin{enumerate}
			\item Purpose\\
			The purpose of this project is to display real 3D camera data as textured meshes.  The depth image from a 3D camera provides a wealth of information, but is fuzzy.  We can apply filtering and processing to the noisy point cloud, but this results in the loss of color data.  The goal is use the filtered point cloud and the original flat image data to reconstruct a representation of 3D objects with small, manageable point clouds that still retains rich and informative visual information. 
			% https://stackoverflow.com/q/47693251
			\item Features
			\begin{itemize}
				\item Display filtered point clouds as textured meshes
				\item Display the robot pose at which the 3D data was captured
				\item Select 3D objects with an intuitive mouse interface
			\end{itemize}
			\item DEMO
			\item Process
			\begin{enumerate}
				\item Data Reading \& Processing \\
				For every ``shot'', the robot system caches the following data
				\begin{itemize}
					\item Camera frame with respect to the lab frame
					\item Robot joint angles
					\item Filtered point clouds in the lab frame
					\item Infrared image (False color)
				\end{itemize}
				\item Mesh Construction \& UV-Matching
				\begin{enumerate}
					\item Transform the coordinates into the camera frame
					\item Triangulate into mesh (covered later)
					\item Match each of the points to a $\left( U,V \right)$ location on the IR image
					\item Construct a bounding box for each of the point cloud clusters generated by the system
				\end{enumerate}
				\item Event Loop
				\begin{enumerate}
					\item Listen for kb and mouse input
					\item Process input
					\item If click: Mouse collision detection
					\item {\tt display()}
				\end{enumerate}
			\end{enumerate}
		\end{enumerate}
		
		\item Cover cool graphics things that you did in your project that I did not talk about in class
		
		\begin{itemize}
			
			\item Processing mouse clicks in the lab frame
			\begin{itemize}
				\item There are four reference frames to contend with: \{Window [pixels] , Cursor [m] , Camera [m] , Lab [m]\}
			\end{itemize}
			\begin{enumerate}
				\item Transform mouse coordinates in screen pixels to relative window coordinates in the range $\left[ -1 , 1 \right]$
				\item Transform window coordinates into cursor coordinates (orthogonal), Draw crosshairs (Turn depth test OFF)
				\item Transform window coordinates info camera frame coordinates.  This must be a right-handed coordinate system with $ \texttt{+} \vz $ pointed down the lens of the camera into the scene
				\item Construct a point at arbitrary $ \texttt{+} \vz $ depth from the origin. $\left(x,y\right)$ are computed using the vertical FOV angle and the current aspect ratio of then screen.
				\item Construct a ray (eye \rarw point) and transform into the lab frame
				\item Now you are ready for collision detection!
			\end{enumerate}
			
			\item Hierarchical Collision Detection
			\begin{enumerate}
				\item Intersection of AABB and ray
				\item Triangle-wise collision detection \\
				For each triangle
				\begin{enumerate}
					\item Construct a plane from triangle and its normal
					\item Get the intersection point between the ray and the plane
					\item Compute winding number (point-in-polygon) \\
					This works for any closed polygon, polygon can self-cross
					\begin{enumerate}
						\item New 2D reference frame with the query point at $\left( 0 , 0 \right)$ 
						\item Follow segments CW around the polygon and count $ \texttt{+} \vx $ crossings
						\item Result can be any integer: positive number is CW circuits around point, negative is CCW 
						\item For any non-zero result, the point is encircled by (inside of) polygon!
					\end{enumerate}
				\end{enumerate}
			\end{enumerate}
			
			\item Nested Coordinate Frames
			\begin{itemize}
				\item You can {\tt glPushMatrix} up to {\tt GL\_MAX\_MODELVIEW\_STACK\_DEPTH}.  This varies between systems but OpenGL specifies this be at least 32.
				\item Paired {\tt glPushMatrix} \& {\tt glPopMatrix} make it \textit{relatively} easy to render a robot character using the standard Denavitâ€“Hartenberg parameters.  DH parameters is a system that specifies serial coordinate transforms across the rigid links of a robot.  I can give by robot character a list of these parameters and each link will apply the appropriate {\tt glTranslate} \& {\tt glRotate} in order to display the correct relative poses between links.
			\end{itemize}
			
		\end{itemize}
		
		\item Cover stuff related to your project that has nothing to do with Computer Graphics
		\begin{itemize}
			\item Delaunay Triangulation, courtesy of Paul Bourke
			\begin{itemize}
				\item Paul Bourke is a big name in computational geometry, and he posts a lot code online with helpful diagrams
				\item A common method to connect a collection of points in triangular mesh
				\item It is the dual of Voronoi Cells
				\item Gotcha: Paul Bourke does not delete allocated memory
			\end{itemize}
			
		\end{itemize}
		
		\item Cover "gotchas" - things that did not work initially, how you figured out the problem, and how you fix it
		\begin{enumerate}
			\item Difference between screen coordinates, orthogonal (flat) coordinates, and model (projection) coordinates
			\item SDL2 function calls are all different from SDL1: Read the docs \textit{carefully}
			\item There are two ways to handle keyboard input in SDL2, Keyboard State \& Event Queue
			\begin{itemize}
				\item Keyboard State: Pro - You won't miss interaction events that begin and end before the next frame , Con - You have to reconstruct kb combination from the series of events
				\item Event Queue: Pro - Easily discern key combinations , Con - Only detect state at the instant you checked it
				\item Mine was a hacky combination of both
			\end{itemize}
			\item SDL2 seems to detect random kb events.  Solution: Check to be sure that the event that happened is a key-down event.
			\item Eigen Library
			\begin{itemize}
				\item Advantages
				\begin{enumerate}
					\item Header-only, no installation required
					\item Cross, Dot, Norm, Squared Norm, Invert, Transpose, SVD, Anything you like
					\item Declaration without size
					\item Clean up after themselves
				\end{enumerate}
				\item Gotchas, There are rules you must follow in order to accommodate memory magic
				\begin{enumerate}
					\item Pass by reference only
					\item {\tt EIGEN\_MAKE\_ALIGNED\_OPERATOR\_NEW} at the beginning of struct/class {\tt public} declaration
					\item Never store in a {\tt std::vector}. \larw It is much, much easier to store as rows in a matrix.  You can assign a row to a vector type
					\item Never feed the matrices after midnight
				\end{enumerate}
			\end{itemize}
			\item Make absolutely sure to call {\tt glDisable( GL\_TEXTURE\_2D )} when you are done drawing with textures, otherwise the color leaks out into the entire state machine. Ew! Blue!
		\end{enumerate}
		
	\end{enumerate}
	
	
	
\end{document}